---
title: 深入理解Java JVM 读书笔记（四）垃圾回收算法
date: 2016-05-25 14:23:25
categories:
- 术业专攻
tags:
- Java
- JVM
- 垃圾回收
---
>上一节内容在书中记叙了如何判断一个对象是否死亡，是否可回收，这一节内容说明三种垃圾收集算法（**标记-清除算法、复制算法、标记-整理算法**），简单介绍几种算法的思想和优缺点。
<!-- more -->

## 标记-清除算法
标记清除算法是最基础的收集算法，其他收集算法都是基于这种思路并对其不足进行改进而得到的。算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成之后统一清除所标记的对象。

主要缺点：
1. 效率问题：标记和清除两个过程效率都不高 
2. 空间问题：标记清除之后会产生大量不连续的内存碎片。

## 复制算法
它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。

主要缺点：
内存缩小为原来的一半。

## 标记-整理算法
标记过程和“标记-清除”算法一样，但后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。

主要缺点：
在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。

## 分代收集算法
根据对象存活周期的不同将内存分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。

新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

老年代中因为对象存活率高、没有额外的空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。