---
title: 深入理解Java JVM 读书笔记（三）Java对象“死”了么？
date: 2016-05-24 13:11:47
categories:
- 术业专攻
tags:
- JVM
- 对象
- 垃圾回收
- Java
---
>JVM管理的堆内存中，几乎存放了所有的对象实例，在垃圾收集器对堆进行回收前，首先就要判断这些对象之中哪些还“存活”,哪些已经死去。当一个对象已经使用完毕（没有任何引用指向它），则该对象所占用的内存应该被回收利用，这些即为JVM垃圾收集器的工作。
<!-- more -->

如何判断一个对象是否已死，通常有两种算法：**引用计数算法**和**可达性分析算法**。

## 引用计数算法
首先讲讲引用，如果reference类型的数据中存储的数据代表的是另一个内存的地址，就称这块这块内存代表一个引用。

很多教科书中判断对象是否存活的算法是这样的：  
>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器的值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

但是目前的主流的Java虚拟机都没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的互相引用的问题。

在Objective-C中使用强引用和若用来解决循环用的问题，这里在JDK1.2之后，Java对引用的概念进行了扩展，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4中，这四种引用强度依次减弱。  
1. 强引用：强引用就是指程序代码中普遍存在的，类似 Object a = new Object（） 这类的引用，只要引用还存在，垃圾收集器永远不会回收掉该引用对象所占内存；  
2. 软引用：软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在内存不足，将要发生内存溢出异常之前，将会把这些对象列入回收范围之中并进行第二次回收；  
3. 弱引用：用来描述非必需对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存时候足够，都将其回收；  
4. 虚引用：它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得对象实例。它的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。

## 可达性分析算法
>可达性分析算法的基本思路就是通过一系列的成为“GC Roots”的对象作为起点，从这些起点开始向下搜索，搜索搜走过的路径为引用链，当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的，不可达的，应该被回收。

如图所示：对象object5、object6、object7虽然相互关联，但是他们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。
![](http://ww4.sinaimg.cn/large/b36cd9dbgw1f46fjipvvrj20d80aw0tc.jpg)

在Java语言中，可作为GC Roots的对象包括下面几种：
* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI(即一般所说的Native方法)引用的对象。

>在可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象的死亡，至少要经过两次标记过程；如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的挑条件是此对象是否有必要执行finalize()方法。

当对象没有没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。  

当这个对象被判定为有必要执行finalize()方法，那么这个对象会放置在一个叫做F-Queue的队列中，并在稍后由一个JVM自动建立的、优先级低的Finalizer线程去执行它，及虚拟机会触发这个方法，但不会承诺等待它运行结束，这样做的原因是当一个对象在F-Queue队列中执行缓慢或者发生死循环，将会导致F-Queue队列中的其它对象永久处于等待状态，甚至整个内存回收系统奔溃。
